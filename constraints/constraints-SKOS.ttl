# Labeling and Documentation Issues - Omitted or Invalid Language Tags
# -----
# Some controlled vocabularies contain literals in natural
# language, but without information what language has actually been used.
# Language tags might also not conform to language standards, such as RFC 3066.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	 
	# data
	# ----
	?subject 
		a [rdfs:subClassOf* skos:Concept] ;
		?p ?l . 
	BIND ( ( LANG ( ?l ) ) AS ?language ) . 
	
	# validation
	# ----------
	FILTER ( ?language = "" ) . 

	# violation message
	# -----
	BIND ( CONCAT( 
		"Omitted or invalid language tags of literals. | The language tag of the literal '", 
		xsd:string( ?p ), 
		"' with the value '", 
		xsd:string( ?l ), 
		"' is omitted.") 
		AS ?violationMessage ) . 
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}


# Labeling and Documentation Issues - Incomplete Language Coverage
# -----
# Some concepts in a thesaurus are labeled in only one language, 
# some in multiple languages. It may be desirable to have each concept
# labeled in each of the languages that also are used on the other concepts.
# This is not always possible, but incompleteness of language coverage for some
# concepts can indicate shortcomings of the vocabulary.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	  	
	{	
		{
			# data
			# ----
			?subject
				a [rdfs:subClassOf* skos:Concept] ;
				?p ?l1 .
			FILTER ( ?p != rdf:type ) .
			BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
			FILTER ( ?language1 = "en" ) .
		
			# validation
			# ----------
			FILTER NOT EXISTS {
  				?subject ?p ?l2 .
    			BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
    			FILTER ( ?language2 = "de" ) .
  			}
  			FILTER NOT EXISTS {
  				?subject ?p ?l3 .
    			BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
    			FILTER ( ?language3 = "fr" ) .
  			}

			# violation message
			# -----------------
			BIND ( CONCAT( 
				"The languages en, de, fr should be covered by each property of each concept | The concept '",
				xsd:string( ?subject ),
				"' only points to an English value via the property '",
				xsd:string( ?p ),
				"'.") 
				AS ?violationMessage ) . 
		}
		UNION
		{
			# data
			# ----
			?subject
				a [rdfs:subClassOf* skos:Concept] ;
				?p ?l1 .
			FILTER ( ?p != rdf:type ) .
			BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
			FILTER ( ?language1 = "de" ) .
		
			# validation
			# ----------
			FILTER NOT EXISTS {
  				?subject ?p ?l2 .
    			BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
    			FILTER ( ?language2 = "en" ) .
  			}
  			FILTER NOT EXISTS {
  				?subject ?p ?l3 .
    			BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
    			FILTER ( ?language3 = "fr" ) .
  			}

			# violation message
			# -----------------
			BIND ( CONCAT( 
				"The languages en, de, fr should be covered by each property of each concept | The concept '",
				xsd:string( ?subject ),
				"' only points to a German value via the property '",
				xsd:string( ?p ),
				"'.") 
				AS ?violationMessage ) . 
		}
	}
	UNION
	{
		{
			{
				# data
				# ----
				?subject
					a [rdfs:subClassOf* skos:Concept] ;
					?p ?l1 .
				FILTER ( ?p != rdf:type ) .
				BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
				FILTER ( ?language1 = "fr" ) .
			
				# validation
				# ----------
				FILTER NOT EXISTS {
					?subject ?p ?l2 .
					BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
					FILTER ( ?language2 = "en" ) .
				}
				FILTER NOT EXISTS {
					?subject ?p ?l3 .
					BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
					FILTER ( ?language3 = "de" ) .
				}

				# violation message
				# -----------------
				BIND ( CONCAT( 
					"The languages en, de, fr should be covered by each property of each concept | The concept '",
					xsd:string( ?subject ),
					"' only points to a French value via the property '",
					xsd:string( ?p ),
					"'.") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				# data
				# ----
				?subject
					a [rdfs:subClassOf* skos:Concept] ;
					?p ?l1 .
				FILTER ( ?p != rdf:type ) .
				BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
				FILTER ( ?language1 = "de" ) .
			
				# validation
				# ----------
				FILTER EXISTS {
					?subject ?p ?l2 .
					BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
					FILTER ( ?language2 = "fr" ) .
				}
				FILTER NOT EXISTS {
					?subject ?p ?l3 .
					BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
					FILTER ( ?language3 = "en" ) .
				}

				# violation message
				# -----------------
				BIND ( CONCAT( 
					"The languages en, de, fr should be covered by each property of each concept | The concept '",
					xsd:string( ?subject ),
					"' only points to a German and a French value via the property '",
					xsd:string( ?p ),
					"'.") 
					AS ?violationMessage ) . 
			}
		}
		UNION
		{
			{
				# data
				# ----
				?subject
					a [rdfs:subClassOf* skos:Concept] ;
					?p ?l1 .
				FILTER ( ?p != rdf:type ) .
				BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
				FILTER ( ?language1 = "en" ) .
			
				# validation
				# ----------
				FILTER EXISTS {
					?subject ?p ?l2 .
					BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
					FILTER ( ?language2 = "de" ) .
				}
				FILTER NOT EXISTS {
					?subject ?p ?l3 .
					BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
					FILTER ( ?language3 = "fr" ) .
				}

				# violation message
				# -----------------
				BIND ( CONCAT( 
					"The languages en, de, fr should be covered by each property of each concept | The concept '",
					xsd:string( ?subject ),
					"' only points to an Englisch and a German value via the property '",
					xsd:string( ?p ),
					"'.") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				# data
				# ----
				?subject
					a [rdfs:subClassOf* skos:Concept] ;
					?p ?l1 .
				FILTER ( ?p != rdf:type ) .
				BIND ( ( LANG ( ?l1 ) ) AS ?language1 ) .
				FILTER ( ?language1 = "en" ) .
			
				# validation
				# ----------
				FILTER EXISTS {
					?subject ?p ?l2 .
					BIND ( ( LANG ( ?l2 ) ) AS ?language2 ) .
					FILTER ( ?language2 = "fr" ) .
				}
				FILTER NOT EXISTS {
					?subject ?p ?l3 .
					BIND ( ( LANG ( ?l3 ) ) AS ?language3 ) .
					FILTER ( ?language3 = "de" ) .
				}

				# violation message
				# -----------------
				BIND ( CONCAT( 
					"The languages en, de, fr should be covered by each property of each concept | The concept '",
					xsd:string( ?subject ),
					"' only points to an Englisch and a French value via the property '",
					xsd:string( ?p ),
					"'.") 
					AS ?violationMessage ) . 
			}
		}
	}
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}


# Labeling and Documentation Issues - No Common Language
# -----
# Checks if all concepts have at least one common language (default: English), 
# i.e. they have assigned at least one literal in the same language.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	?subject 
		a [rdfs:subClassOf* skos:Concept] .

	# validation
	# ----------
	FILTER NOT EXISTS {
		?subject ?p ?l .
		BIND ( ( LANG ( ?l ) ) AS ?lang ) .
		FILTER ( ?lang = "en" ) .
	}

	# violation message
	# -----------------
	BIND ( CONCAT( 
		"Each concept must have at least 1 literal in the same common language (en) | ",
		"The concept '",
		xsd:string( ?subject ),
		"' does not have a literal in the same common language (en)." ) 
		AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}


# Labeling and Documentation Issues - Undocumented Concepts
# -----
# The SKOS standard defines a number of properties useful for
# documenting the meaning of the concepts in a thesaurus also in a human-
# readable form. Intense use of these properties leads to a well-documented
# thesaurus which should also improve its quality. 
# Implementation: Iteration over all concepts
# in the vocabulary and find those not using one of skos:note, skos:changeNote,
# skos:definition, skos:editorialNote, skos:example, skos:historyNote, or skos:scopeNote.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	  	
	# data
	# ----
	?subject a ?class .
	?class rdfs:subClassOf* skos:Concept .
	
	# validation
	# ----------
	FILTER NOT EXISTS { 
		{ { ?subject skos:note ?x } UNION { ?subject skos:changeNote ?x } . }
		UNION 
		{ { ?subject skos:definition ?x } UNION { ?subject skos:editorialNote ?x } . }
		UNION 
		{ { ?subject skos:example ?x } UNION { ?subject skos:historyNote ?x } . }
		UNION 
		{ ?subject skos:scopeNote ?x } .
	}  

	# violation message
	# -----
	BIND ( CONCAT( 
		"The concept '", 
		xsd:string( ?subject ), 
		"' does not use one of skos:note, skos:changeNote, skos:definition, skos:editorialNote, skos:example, skos:historyNote, or skos:scopeNote.",
		" | The SKOS standard defines a number of properties useful for documenting the meaning of the concepts in a thesaurus also in a human-readable form. Intense use of these properties leads to a well-documented thesaurus which should also improve its quality.") 
		AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .		
}


# Labeling and Documentation Issues - Overlapping Labels
# -----
# This is a generalization of a recommendation in the SKOS primer,
# that no two concepts have the same preferred lexical label in a given
# language when they belong to the same concept scheme. This could indicate
# missing disambiguation information and thus lead to problems in auto-completion application.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	  	
	# data
	# ----
	?subject
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?conceptScheme ;
		?p ?label1 .
	BIND ( ( STR ( ?label1 ) ) AS ?l1 ) .
	BIND ( ( LANG ( ?label1 ) ) AS ?lang1 ) .
	?concept 
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?conceptScheme ;
		?p ?label2 .
	BIND ( ( STR ( ?label2 ) ) AS ?l2 ) .
	BIND ( ( LANG ( ?label2 ) ) AS ?lang2 ) .
	?conceptScheme
		a [rdfs:subClassOf* skos:ConceptScheme] .
		
	# validation
	# ----------
	FILTER ( ?subject != ?concept ) .
	FILTER ( ?l1 = ?l2 ) .
	FILTER ( ?lang1 = ?lang2 ) . 

	# violation message
	# -----
	BIND ( CONCAT( 
		"Two concepts cannot have the same preferred lexical label in a given language when they belong to the same concept scheme | '", 
		"The concept '", 
		xsd:string( ?subject ), 
		"' and the concept '",
		xsd:string( ?concept ), 
		"', belonging to the same concept scheme '",
		xsd:string( ?conceptScheme ), 
		"', have the same preferred lexical label '",
		xsd:string( ?l1 ), 
		"' in the given language '",
		xsd:string( ?lang1 ), 
		"'.'"
		) AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .		
}


# Labeling and Documentation Issues - Missing Labels
# -----
# To make the vocabulary more convenient for humans to use, instances
# of SKOS classes (Concept, ConceptScheme, Collection) should be labeled
# using e.g., skos:prefLabel, altLabel, rdfs:label, dc:title.

PREFIX dcterms: <http://purl.org/dc/terms#> 
PREFIX rdf:	    <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos:    <http://www.w3.org/2004/02/skos/core#>
PREFIX :        <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	  	
	# data
	# ----
	{ { ?subject a [rdfs:subClassOf* skos:Concept] } UNION { ?subject a [rdfs:subClassOf* skos:ConceptScheme] } . }
	UNION 
	{ { ?subject a [rdfs:subClassOf* skos:Collection] } UNION { ?subject a [rdfs:subClassOf* skos:OrderedCollection] } . }

	# validation
	# ----------
	FILTER NOT EXISTS {
		{ { ?subject skos:prefLabel ?l } UNION { ?subject skos:altLabel ?l } . }
		UNION 
		{ { ?subject rdfs:label ?l } UNION { ?subject dcterms:title ?l } . }
	} 

	# violation message
	# -----
	BIND ( CONCAT( 
		"SKOS classes ( Concept, ConceptScheme, Collection, OrderedCollection ) should be labeled with e.g. skos:prefLabel, skos:altLabel, rdfs:label, dcterms:title '", 
		"to make the vocabulary more convenient for humans to use. | ",  
		xsd:string( ?subject ), 
		"' is not labeled."
		) AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .		
}


# Labeling and Documentation Issues - Empty Labels
# -----
# Labels also need to contain textual information to be useful, thus we
# find all SKOS labels with length 0 (after removing whitespaces).

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	  	
	# data
	# ----
	{ { ?subject a [rdfs:subClassOf* skos:Concept] } UNION { ?subject a [rdfs:subClassOf* skos:ConceptScheme] } . }
	UNION 
	{ { ?subject a [rdfs:subClassOf* skos:Collection] } UNION { ?subject a [rdfs:subClassOf* skos:OrderedCollection] } . }
	?subject ?p ?literal .
	BIND ( STR ( ?literal ) AS ?l ) .

	# validation
	# ----------
	FILTER ( ?l = "" ) . 

	# violation message
	# -----
	BIND ( CONCAT( 
		"Labels are needed to contain textual information to be useful. | The property '",  
		xsd:string( ?p ), 
		"' points to an empty label."
		) AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .	
}


# Labeling and Documentation Issues - Ambiguous Notation References
# -----
PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	 
	# data
	# ---- 
	?subject 
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?cs ;
        skos:notation ?l1 .
	?concept 
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?cs ;
        skos:notation ?l1 .
	
	# validation
	# ----------
    #FILTER ( ?cs = ?conceptScheme ) .
    FILTER ( ?subject != ?concept ) .
    #FILTER ( ?l1 = ?l2 ) .
	
	# violation message
	# -----
	BIND ( STR ( ?l1 ) AS ?l1_str ) .
	BIND ( CONCAT( 
		"Concepts within the same concept scheme should not have identical skos:notation literals | The concept '",  
		xsd:string( ?subject ), 
		"' and the concept '",
		xsd:string( ?concept ), 
		"' within the same concept scheme '",
		xsd:string( ?cs ), 
		"' have an identical skos:notation literal '",
		xsd:string( ?l1_str ), 
		"'."
		) AS ?violationMessage ) . 
		
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}
LIMIT 10

# alternative, but not permorming well:
PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?s ?violationMessage
WHERE {	  	
	# data
	# ----
	?s 
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?conceptScheme ;
		skos:notation ?l .
	?conceptScheme
		a [rdfs:subClassOf* skos:ConceptScheme] .
	{
		VALUES ?subject {?s}
	    {
			SELECT ( COUNT ( ?concept ) AS ?count )
			WHERE {
				?concept 
					a [rdfs:subClassOf* skos:Concept] ;
					skos:inScheme ?conceptScheme ;
					skos:notation ?l .
					FILTER ( ?subject != ?concept ) .
			}
		}
	}
		
	# validation
	# ----------
	#FILTER ( ?count != 0 ) .

	# violation message
	# -----
	BIND ( STR ( ?conceptScheme ) AS ?cs_str ) .
	BIND ( STR ( ?l ) AS ?l_str ) .
	BIND ( CONCAT( 
		"Concepts with the same concept scheme should not have identical skos:notation literals | The concept '",  
		xsd:string( ?s ), 
		"' and another concept with the same concept scheme '",
		xsd:string( ?cs_str ), 
		"' have the identical skos:notation literal '",
		xsd:string( ?l_str ), 
		"'."
		) AS ?violationMessage ) . 
}

# alternative, but not permorming well:
PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?s ?violationMessage ?severityLevel
WHERE {	 
	# data
	# ---- 
	?s 
		a [rdfs:subClassOf* skos:Concept] ;
		skos:inScheme ?cs ;
        skos:notation ?l1 .
	
	# subquery
	# ----
	{
		SELECT ?concept ?conceptScheme ?l2
		WHERE {
			?concept 
				a [rdfs:subClassOf* skos:Concept] ;
				skos:inScheme ?conceptScheme ;
                skos:notation ?l2 .
		}
	} 
	
	# validation
	# ----------
    FILTER ( ?cs = ?conceptScheme ) .
    FILTER ( ?s != ?concept ) .
    FILTER ( ?l1 = ?l2 ) .
	
	# violation message
	# -----
	BIND ( STR ( ?l1 ) AS ?l1_str ) .
	BIND ( CONCAT( 
		"Concepts within the same concept scheme should not have identical skos:notation literals | The concept '",  
		xsd:string( ?s ), 
		"' and another concept within the same concept scheme '",
		xsd:string( ?cs ), 
		"' have the identical skos:notation literal '",
		xsd:string( ?l1_str ), 
		"'."
		) AS ?violationMessage ) . 
		
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}

# Structural Issues - Orphan Concepts
# -----
# An orphan concept is a concept without any associative or hierarchical relations. It might have
# attached literals like e.g., labels, but is not connected to any other resource,
# lacking valuable context information. A controlled vocabulary that contains
# many orphan concepts is less usable for search and retrieval use cases, 
# because, e.g., no hierarchical query expansion can be performed on search terms
# to find documents with more general content.
# Implementation: Iteration over all concepts in the vocabulary and re-
# turning that don’t have associated resources using (sub-properties of) skos:semanticRelation.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	 
	# data
	# ----
	?subject a [rdfs:subClassOf* skos:Concept] .
		
	# validation
	# ----------
	FILTER NOT EXISTS {
		?subject ?p ?o .
		FILTER ( ?p IN ( 
		skos:related,
		skos:relatedMatch,
		skos:broader,
		skos:broadMatch,
		skos:narrower,
		skos:narrowMatch,
		skos:closeMatch,
		skos:exactMatch,
		skos:relatedMatch,
		skos:broadMatch,
		skos:narrowMatch ) ) .	 
	}
	
	# violation message
	# -----
	BIND ( CONCAT( 
		"The concept '", 
		xsd:string( ?subject ), 
		"' does not have any associative or hierarchical relations.",
		" | A controlled vocabulary that contains many orphan concepts is less usable for search and retrieval use cases. ") 
		AS ?violationMessage ) . 
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}


# Structural Issues - Disconnected Concept Clusters
# -----
# Checking the connectivity of the graph, it is possible to identify all weakly connected
# components. These data sets form islands in the vocabulary and might be
# caused by incomplete data acquisition, forgotten test data, out-dated terms and the like.
# Implementation: Creation of an undirected graph that includes all non-
# orphan concepts as nodes and all semantic relations as edges. Tarjan’s
# algorithm then finds and returns all weakly connected components.

# Not yet implemented


# Structural Issues - Cyclic Hierarchical Relations
# -----
# Although perfectly consistent with the SKOS data model, cyclic relations may reveal
# a logical problem in the thesaurus. Consider the following example: 
# decision --> problem resolution --> problem --> decision: here the cycle is
# closed). The concepts are connected using skos:broader relationships
# (indicated with -->). Due to the fact that a thesaurus is in many cases a product
# of consensus between the contributors (or just the decision of one dedicated
# thesaurus manager), it will be almost impossible to automatically resolve
# the cycle (i.e. deleting an edge).
# Implementation: Construction of a graph having all concepts as nodes
# and the set of edges being skos:broader relations.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	?subject a [rdfs:subClassOf* skos:Concept] .
		
	# validation
	# ----------
	?subject skos:broader* ?o .
	?o skos:broader* ?subject .
	FILTER ( ?subject != ?o ) .

	# violation message
	# -----
	BIND ( CONCAT( 
		"There is a cyclic relation between the concept '", 
		xsd:string( ?subject ), 
		"' and the concept '",
		xsd:string( ?o ),
		"'. | cyclic relations may reveal a logical problem in the thesaurus. ") 
		AS ?violationMessage ) .
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}


# Structural Issues - Valueless Associative Relations
# -----
# Two concepts are sibling, but also connected by an associative relation. 
# In that context, the associative relation is not necessary. See ISO DIS 25964-1, 11.3.2.2
# Implementation: Identification of all pairs of concepts that have the same
# broader or narrower concepts, i.e. they are sibling terms. All siblings
# that are related by a skos:related property are returned.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
{
	# data
	# ---- 
	?subject
		a [rdfs:subClassOf* skos:Concept] ;
		skos:related ?sibling ;
		skos:broader ?TopConcept .
	?sibling 
		a [rdfs:subClassOf* skos:Concept] ; 
		skos:related ?subject ;
		skos:broader ?TopConcept .                    
	FILTER ( ?subject != ?sibling ) .
	?TopConcept 
		a [rdfs:subClassOf* skos:Concept] .	 

	# violation message
	# -----
	BIND ( CONCAT( 
		"The concepts '", 
		xsd:string( ?subject ), 
		"' and '", 
		xsd:string( ?sibling ),
		"' are siblings (having the same broader concepts), but are also connected by a not necessary associative relation (skos:related).") 
		AS ?violationMessage ) . 
}
UNION
{
	# data
	# ---- 
	?subject
		a [rdfs:subClassOf* skos:Concept] ;
		skos:related ?sibling ;
		skos:narrower ?BottomConcept .
	?sibling 
		a [rdfs:subClassOf* skos:Concept] ; 
		skos:related ?subject ;
		skos:narrower ?BottomConcept .
	FILTER ( ?subject != ?sibling ) .
	?BottomConcept 
		a [rdfs:subClassOf* skos:Concept] .		 

	# violation message
	# -----
	BIND ( CONCAT( 
		"The concepts '", 
		xsd:string( ?subject ), 
		"' and '", 
		xsd:string( ?sibling ),
		"' are siblings (having the same narrower concepts), but are also connected by a not necessary associative relation (skos:related).") 
		AS ?violationMessage ) . 
}
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}


# Structural Issues - Solely Transitively Related Concepts
# -----
# skos:broaderTransitive and skos:narrowerTransitive are, according to the SKOS reference document,
# not used to make assertions, so they should not be the only relations hierarchically relating two concepts.
# Implementation: Identification of all concept pairs that are related by
# skos:broaderTransitive or skos:narrowerTransitive properties but not by
# their skos:broader and skos:narrower sub-properties.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	{
		# data
		# ----
		?subject 
			a [rdfs:subClassOf* skos:Concept] ;
			skos:narrowerTransitive ?object .
		?object
			a [rdfs:subClassOf* skos:Concept] ;
			skos:broaderTransitive ?subject .
		FILTER ( ?subject != ?object ) .
			
		# validation
		# ----------
		FILTER NOT EXISTS {
			?subject ?narrower ?object .
			FILTER ( ?narrower IN (
			skos:narrower,
			skos:narrowMatch ) ) .	 
			
			?object ?broader ?subject .
			FILTER ( ?broader IN ( 
			skos:broader,
			skos:broadMatch ) ) .	
		}

		# violation message
		# -----
		BIND ( CONCAT( 
			"The concept '", 
			xsd:string( ?subject ),
			"' is only related to the concept '", 
			xsd:string( ?object ), 
			"' by the transitive property skos:narrowerTransitive",
			", but not by skos:narrower sub-properties. | skos:broaderTransitive and skos:narrowerTransitive are not used to make assertions, so they should not be the only relations hierarchically relating two concepts. ")
			AS ?violationMessage ) . 
	}
	UNION
	{
		# data
		# ----
		?subject 
			a [rdfs:subClassOf* skos:Concept] ;
			skos:broaderTransitive ?object .
		?object
			a [rdfs:subClassOf* skos:Concept] ;
			skos:narrowerTransitive ?subject .
		FILTER ( ?subject != ?object ) .
			
		# validation
		# ----------
		FILTER NOT EXISTS {
			?subject ?broader ?object .
			FILTER ( ?broader IN ( 
			skos:broader,
			skos:broadMatch ) ) . 
			
			?object ?narrower ?subject .
			FILTER ( ?narrower IN (
			skos:narrower,
			skos:narrowMatch ) ) .		
		}

		# violation message
		# -----
		BIND ( CONCAT( 
			"The concept '", 
			xsd:string( ?subject ),
			"' is only related to the concept '", 
			xsd:string( ?object ), 
			"' by the transitive property skos:broaderTransitive",
			", but not by skos:broader sub-properties. | skos:broaderTransitive and skos:narrowerTransitive are not used to make assertions, so they should not be the only relations hierarchically relating two concepts. ")
			AS ?violationMessage ) . 
	} 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}


# Structural Issues - Unidirectionally Related Concepts
# -----
# Reciprocal relations (skos:broader/skos:narrower, skos:hasTopConcept/skos:topConceptOf, 
# skos:narrowerTransitive/skos:broaderTransitive, skos:narrowMatch/skos:broadMatch )
# should be included in the controlled vocabularies to achieve better search
# results using SPARQL in systems without reasoner support.
# Implementation: This issue is checked without inference of owl:inverseOf
# properties. We iterate over all triples and check for each property if an
# inverse property is defined in the SKOS ontology and if the respective
# statement using this property is included in the vocabulary. If not, the
# resources associated with this property are returned.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# -----
	?subject
		a [rdfs:subClassOf* skos:Concept] .
		
	# validation
	# -----
	{
		{
			{
				?subject skos:broader ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:narrower ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:broader' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				?subject skos:hasTopConcept ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:topConceptOf ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:hasTopConcept' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
		}
		UNION
		{
			{
				?subject skos:narrowerTransitive ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:broaderTransitive ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:narrowerTransitive' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				?subject skos:narrowMatch ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:broadMatch ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:narrowMatch' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
		}
	}
	UNION
	{
		{
			{
				?subject skos:narrower ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:broader ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:narrower' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				?subject skos:topConceptOf ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:hasTopConcept ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:topConceptOf' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
		}
		UNION
		{
			{
				?subject skos:broaderTransitive ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:narrowerTransitive ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:broaderTransitive' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
			UNION
			{
				?subject skos:broadMatch ?o .
				?o a [rdfs:subClassOf* skos:Concept] .
				FILTER NOT EXISTS {
					?o skos:narrowMatch ?subject .  
				}
				# violation message
				# -----
				BIND ( CONCAT( 
					"The concept '", 
					xsd:string( ?subject ),
					"' is related to the concept '", 
					 xsd:string( ?o ),
					"' via the object property 'skos:broadMatch' only unidirectionally.", 
					" | Reciprocal relations should be included in the controlled vocabularies to achieve better search results using SPARQL in systems without reasoner support. ") 
					AS ?violationMessage ) . 
			}
		}
	}
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}

# Structural Issues - Omitted Top Concepts
# -----
# A vocabulary should provide entry points to the data to provide efficient access
# and guidance for human users.
# Implementation: For every ConceptScheme in the controlled vocabulary,
# a SPARQL query is issued finding resources that are associated with
# this ConceptScheme by one of the properties skos:hasTopConcept or
# skos:topConceptOf. Top concepts are also concepts having no broader concept.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	
		
	# validation
	# ----------
	{
		?subject a [rdfs:subClassOf* skos:ConceptScheme] .
		FILTER NOT EXISTS {
			?subject
				skos:hasTopConcept ?concept .
			?concept
				a [rdfs:subClassOf* skos:Concept] .
		}
		FILTER NOT EXISTS {
			?concept
				a [rdfs:subClassOf* skos:Concept] ;
				skos:topConceptOf ?subject .
		}
		
		# violation message
		# -----
		BIND ( CONCAT( 
			"The concept scheme '", 
			xsd:string( ?subject ),
			"' does not have any top concept. ",
			"| A vocabulary should provide entry points to the data to provide efficient access and guidance for human users.") 
			AS ?violationMessage ) . 
	}
	UNION
	{
		?subject a [rdfs:subClassOf* skos:Concept] .
		FILTER NOT EXISTS {
			?subject skos:broader ?conceptScheme .
		}
		FILTER NOT EXISTS {
			?subject skos:topConceptOf ?conceptScheme .
		}
		FILTER NOT EXISTS {
			?conceptScheme skos:hasTopConcept ?subject .
		}
		
		# violation message
		# -----
		BIND ( CONCAT( 
			"The concept '", 
			xsd:string( ?subject ),
			"' does not have any broader concept or is not a top concept of a concept scheme. ",
			"| A vocabulary should provide entry points to the data to provide efficient access and guidance for human users.") 
			AS ?violationMessage ) . 
	}   
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}

# Structural Issues - Hierarchical Redundancy
# -----
# As stated in the SKOS reference document, skos:broader and skos:narrower are not
# transitive properties. However, they are sub-properties of skos:broaderTransitive
# and skos:narrowerTransitive which enables inference of a transitive
# closure. This, in fact, leaves it up to the user to interpret whether a 
# vocabulary’s hierarchical structure is seen as transitive or not. In the former case,
# this check can be useful. It finds pairs of concepts (A,B) that are directly
# hierarchically related but there also exits an hierarchical path through a
# concept C that connects A and B.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data 
	# -----
	?subject 
		a [rdfs:subClassOf* skos:Concept] .
			
	{
		?subject
			skos:broader ?B ;
			skos:broader ?C .
		?B 
			a [rdfs:subClassOf* skos:Concept] ; 
			skos:broader* ?C .
		?C
			a [rdfs:subClassOf* skos:Concept] .	 
			
		FILTER ( ?subject != ?B ) .
		FILTER ( ?subject != ?C ) .
		FILTER ( ?B != ?C ) .

		# violation message
		# -----
		BIND ( CONCAT( 
			"skos:broader and skos:narrower are not transitive properties. | The concept '", 
			xsd:string( ?subject ), 
			"' is directly related ( skos:broader ) to the concept '", 
			xsd:string( ?B ),
			"' and transitively related ( skos:broader ) to the concept '", 
			xsd:string( ?C ),
			"'.") 
			AS ?violationMessage ) .
	}
	UNION
	{
		?subject
			skos:narrower ?B ;
			skos:narrower ?C .
		?B 
			a [rdfs:subClassOf* skos:Concept] ; 
			skos:narrower* ?C .
		?C
			a [rdfs:subClassOf* skos:Concept] .	 
			
		FILTER ( ?subject != ?B ) .
		FILTER ( ?subject != ?C ) .
		FILTER ( ?B != ?C ) .

		# violation message
		# -----
		BIND ( CONCAT( 
			"skos:broader and skos:narrower are not transitive properties. | The concept '", 
			xsd:string( ?subject ), 
			"' is directly related ( skos:narrower ) to the concept '", 
			xsd:string( ?B ),
			"' and transitively related ( skos:narrower ) to the concept '", 
			xsd:string( ?C ),
			"'.") 
			AS ?violationMessage ) .
	} 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}


# Structural Issues - Reflexive Relations
# -----
# Concepts related to themselves.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	?subject a [rdfs:subClassOf* skos:Concept] .
		
	# validation
	# ----------
	?subject ?p ?subject .

	# violation message
	# -----
	BIND ( CONCAT( 
		"Reflexive concepts are not allowed. | The concept '", 
		xsd:string( ?subject ), 
		"' is related to itself via the property '",
		xsd:string( ?p ),
		"'.") 
		AS ?violationMessage ) . 
	BIND ( ( 'WARNING' ) AS ?severityLevel ) .
}


# Linked Data Specific Issues - Undefined SKOS Resources
# -----
# The vocabulary should not invent any new terms within the 
# SKOS namespace or use deprecated SKOS elements.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	
	
	# validation
	# ----------
	{
		FILTER( ! REGEX( STR( ?p ), "^http://www.w3.org/2000/01/rdf-schema#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://www.w3.org/1999/02/22-rdf-syntax-ns#" ) ) .	
		FILTER( ! REGEX( STR( ?p ), "^http://spinrdf.org/sp#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://spinrdf.org/spin#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://spinrdf.org/spl#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://www.w3.org/2002/07/owl#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://spinrdf.org/spinx#" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://purl.org/dc/terms/" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://www.w3.org/1999/xhtmlhead" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://purl.org/dc/elements/1.1/" ) ) .
		FILTER( ! REGEX( STR( ?p ), "^http://www.w3.org/2004/02/skos/core#definition" ) ) .
	
		?subject ?p ?o .
		FILTER NOT EXISTS {
			?p a rdf:Property .
		}
		
		# violation message
		# -----------------
		BIND ( CONCAT( 
			"Vocabulary | The property '", 
			xsd:string( ?p ), 
			"' is not defined within a vocabulary." ) 
			AS ?violationMessage ) . 
	}
	UNION
	{
		FILTER( ! REGEX( STR( ?c ), "^http://www.w3.org/2000/01/rdf-schema#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://www.w3.org/1999/02/22-rdf-syntax-ns#" ) ) .	
		FILTER( ! REGEX( STR( ?c ), "^http://spinrdf.org/sp#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://spinrdf.org/spin#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://spinrdf.org/spl#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://www.w3.org/2002/07/owl#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://spinrdf.org/spinx#" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://purl.org/dc/terms/" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://www.w3.org/1999/xhtmlhead" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://purl.org/dc/elements/1.1/" ) ) .
		FILTER( ! REGEX( STR( ?c ), "^http://www.w3.org/2004/02/skos/core#definition" ) ) .
	
		?subject a ?c .
		FILTER NOT EXISTS {
			?c a owl:Class .
		}
		
		# violation message
		# -----------------
		BIND ( CONCAT( 
			"Vocabulary | The class '", 
			xsd:string( ?c ), 
			"' is not defined within a vocabulary." ) 
			AS ?violationMessage ) . 
	}
	BIND ( ( 'ERROR' ) AS ?severityLevel ) .
}


# Linked Data Specific Issues - HTTP URI Scheme Violation
# -----
# In the context of Linked Data, we restrict ourselves to using HTTP URIs only and 
# avoid other URI schemes such as URNs and DOIs.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	?subject ?p ?o .
	
	# validation
	# ----------
	# URI does not start with 'http'
	FILTER( REGEX( STR( ?subject ), "^(?!http).+" ) ) .	 

	# violation message
	# -----
	BIND ( CONCAT( 
		"In the context of Linked Data, we restrict ourselves to using HTTP URIs only and avoid other URI schemes such as URNs and DOIs.")
		AS ?violationMessage ) . 
	BIND ( ( 'ERROR' ) AS ?severityLevel ) .
}


# SKOS Semi-Formal Consistency Issues - Inconsistent Preferred Labels
# -----
# According to the SKOS reference document, a resource has
# no more than one value of skos:prefLabel per language tag.

PREFIX rdf:	 <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX :     <http://data#>
SELECT ?subject ?violationMessage ?severityLevel
WHERE {	
	# data
	# ----
	?subject skos:prefLabel ?label1 .
	?subject skos:prefLabel ?label2 .
	
	BIND ( ( STR ( ?label1 ) ) AS ?label1Str ) .
	BIND ( ( STR ( ?label2 ) ) AS ?label2Str ) . 
	BIND ( ( LANG ( ?label1 ) ) AS ?language1 ) . 
	BIND ( ( LANG ( ?label2 ) ) AS ?language2 ) . 
	
	# validation
	# ----------
	FILTER ( ?label1 != ?label2 ) .
	FILTER ( ?label1Str != ?label2Str ) .
	FILTER ( ?language1 = ?language2 ) .

	# violation message
	# -----
	BIND ( CONCAT( 
		"A resource has no more than one value of skos:prefLabel per language tag | The resource '", 
		xsd:string( ?subject ),
		"' has more than one value of skos:prefLabel: '",
		xsd:string( ?label1Str ), 
		"' and '",
		xsd:string( ?label2Str ),
		"' for the language tag '",
		xsd:string( ?language1 ), 
		"'." 
		) AS ?violationMessage ) . 
	BIND ( ( 'INFO' ) AS ?severityLevel ) .
}